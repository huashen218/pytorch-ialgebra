from ialgebra.utils.utils_interpreter import *

class Compositer(object):
    """
    *Function*: 
    composite saliency_maps to meet user demands
    operators: ['slct',   'proj',  'join', 'anjo']
    queries:   ['select', 'where', 'join', 'left join']

    *Inputs*:
    :input:
    :model:
    :int_map: saliency_map generated by identity
    :interpreter_params:  set default if no user inputs
    :operator_params:

    *Returns*:
    :opt_map: shape = [B*C*H*W], type = numpy.ndarray
    :opt_map+img (might not use): shape = [B*C*H*W], type = numpy.ndarray 
    """


    def __init__(self, inputs_tup,  models_tup, identity_name, identity_kwargs, operators_tup, operators_kwargs_tup):
        # parsing inputs
        self.inputs_tup = inputs_tup

        # parsing models
        self.model_kwargs = models_tup[0]         # (model1_kwargs, model2_kwargs, ..., modeln_kwargs)
        # self.model = load_pretrained_model(**self.model_kwargs)

        # parsing identity
        self.identity = identity_name
        self.identity_kwargs = identity_kwargs

        # parsing operator
        self.operator = operators_tup[0]                  # (operator1, operator2 ,..., operatorn)
        self.operators_kwargs = operators_kwargs_tup[0]   # (operator1_kwargs, operator2_kwargs ,..., operatorn_kwargs)

        self.identity_interpreter = generate_identity(self.bx, self.by, self.model_kwargs, self.identity, self.identity_kwargs)



    ###### TWO Pairs ######
    # select * from f(x) where w
    def slct_proj(self, region):
        """
        *Function*
        :combinition of 'selection' and 'projection':

        *Inputs*:
        :1 input: x
        :1 model: f
        :region: [pos0, pos1, pos2, pos3]

        *Returns*:
        :opt_map: shape = [B*C*H*W], type = numpy.ndarray
        :opt_map+img: shape = [B*C*H*W], type = numpy.ndarray 
        """
        self.identity_interpreter = generate_identity(self.bx, self.by, self.model_kwargs, self.identity, self.identity_kwargs)

        pos0, pos1, pos2, pos3 = region[0], region[1], region[2], region[3]
        img = self.bx
        mat = np.zeros(img.shape)
        roi = img[:, int(pos0):int(pos1), int(pos2):int(pos3)]
        mat[:, int(pos0):int(pos1), int(pos2):int(pos3)] = roi
        mat = mat.astype('float32')

        heatmap, heatmapimg = self.identity_interpreter(mat)
        return heatmap, heatmapimg 
    


    # select * from f(x) join (select * from f(x'))
    def slct_join(self, region1, region2):
        """
        *Function*
        :combinition of 'selection' and 'join':

        *Inputs*:
        :2 input: x, x'
        :1 model: f

        *Returns*:
        :common heatmap: 
        :heatmapimg1:  
        :heatmapimg2: 
        """

        bx1, by1 = self.inputs_tup[0][0], self.inputs_tup[0][1] 
        bx2, by2 = self.inputs_tup[1][0], self.inputs_tup[1][1]

        pos1_0, pos1_1, pos1_2, pos1_3 = region1[0], region1[1], region1[2], region1[3]
        mat1 = np.zeros(bx1.shape)
        roi1 = bx1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)]
        mat1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)] = roi1
        mat1 = mat1.astype('float32')

        pos2_0, pos2_1, pos2_2, pos2_3 = region2[0], region2[1], region2[2], region2[3]
        mat2 = np.zeros(bx2.shape)
        roi2 = bx1[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)]
        mat2[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)] = roi2
        mat2 = mat2.astype('float32')

        ###### ??? todo, mat1 -> prediction != by1??)
        heatmap1, heatmapimg1 = self.identity_interpreter(mat1, by1)
        heatmap2, heatmapimg2 = self.identity_interpreter(mat2, by2)

        heatmap = 0.5 * (heatmap1 + heatmap2)
        
        heatmapimg1 =  heatmap + np.float32(mat1)
        heatmapimg1 = heatmapimg1 / np.max(heatmapimg1)

        heatmapimg2 =  heatmap + np.float32(mat2)
        heatmapimg2 = heatmapimg2 / np.max(heatmapimg2)

        return heatmap, heatmapimg1, heatmapimg2


    # select * from f(x) left join (select * from f(x'))
    def slct_anjo(self, region1, region2 = None, model_diff= False):
        """
        *Function*
        :combinition of 'selection' and 'anti-join':

        *Inputs*:
        case1:  2 input: x, x';   1 model: f
        case2:  1 input: x;       2 models: f, f'

        *Returns*:
        :heatmap1
        :heatmapimg1
        :heatmap2
        :heatmapimg2
        """

        if model_diff:
            bx, by = self.inputs_tup[0][0], self.inputs_tup[0][1] 
            pos1_0, pos1_1, pos1_2, pos1_3 = region1[0], region1[1], region1[2], region1[3]
            mat1 = np.zeros(bx.shape)
            roi1 = bx[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)]
            mat1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)] = roi1
            mat1 = mat1.astype('float32')

            self.model_kwargs1 = models_tup[0] 
            self.model1 = load_pretrained_model(**self.model_kwargs1)
            by1 = self.model1(bx)
            self.identity_interpreter1 = generate_identity(bx, by1, self.model_kwargs1, self.identity, self.identity_kwargs)

            self.model_kwargs2 = models_tup[1] 
            self.model2 = load_pretrained_model(**self.model_kwargs2)
            by2 = self.model2(bx)
            self.identity_interpreter2 = generate_identity(mat1, by2, self.model_kwargs2, self.identity, self.identity_kwargs)

            heatmap1_1, heatmapimg1_1 = self.identity_interpreter1(mat1, by1)  # interpreter1_cls1
            heatmap1_2, heatmapimg1_2 = self.identity_interpreter2(mat1, by1)  # interpreter2_cls1
            heatmap2_1, heatmapimg2_1 = self.identity_interpreter1(mat1, by2)  # interpreter1_cls2
            heatmap2_2, heatmapimg2_2 = self.identity_interpreter2(mat1, by2)  # interpreter2_cls2

        else:
            bx1, by1 = self.inputs_tup[0][0], self.inputs_tup[0][1] 
            bx2, by2 = self.inputs_tup[1][0], self.inputs_tup[1][1]

            pos1_0, pos1_1, pos1_2, pos1_3 = region1[0], region1[1], region1[2], region1[3]
            mat1 = np.zeros(bx1.shape)
            roi1 = bx1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)]
            mat1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)] = roi1
            mat1 = mat1.astype('float32')

            pos2_0, pos2_1, pos2_2, pos2_3 = region2[0], region2[1], region2[2], region2[3]
            mat2 = np.zeros(bx2.shape)
            roi2 = bx2[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)]
            mat2[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)] = roi2
            mat2 = mat2.astype('float32')

            self.identity_interpreter1 = generate_identity(mat1, by1, self.model_kwargs, self.identity, self.identity_kwargs)
            self.identity_interpreter2 = generate_identity(mat2, by2, self.model_kwargs, self.identity, self.identity_kwargs)
 
            heatmap1_1, heatmapimg1_1 = self.identity_interpreter1(mat1, by1)  # interpreter1_cls1_input1
            heatmap1_2, heatmapimg1_2 = self.identity_interpreter2(mat1, by2)  # interpreter2_cls2_input1
            heatmap2_1, heatmapimg2_1 = self.identity_interpreter1(mat2, by1)  # interpreter1_cls1_input2
            heatmap2_2, heatmapimg2_2 = self.identity_interpreter2(mat2, by2)  # interpreter2_cls2_input2

        heatmap1 = 0.5 * (heatmap1_1 + heatmap2_1)
        heatmapimg1 =  heatmap1 + np.float32(bx)
        heatmapimg1 = heatmapimg1 / np.max(heatmapimg1)

        heatmap2 = 0.5 * (heatmap1_2 + heatmap2_2)
        heatmapimg2 =  heatmap2 + np.float32(bx)
        heatmapimg2 = heatmapimg2 / np.max(heatmapimg2)

        return heatmap1, heatmapimg1, heatmap2, heatmapimg2 





    # select * from f(x1)  join  (select * from f(x2) join (select * from f(x3)))
    def proj_join(self):
        """
        *Function*
        :combinition of 'projection' and 'join':

        *Inputs*:
        :2 input: x, x'
        :1 model: f

        *Returns*:
        :common heatmap: 
        :heatmapimg1:  
        :heatmapimg2: 
        """
        bx1, by1 = self.input_tup[0][0], self.input_tup[0][1] 
        bx2, by2 = self.input_tup[1][0], self.input_tup[1][1]

        heatmap1, heatmapimg1 = self.identity_interpreter(bx1, by1)
        heatmap2, heatmapimg2 = self.identity_interpreter(bx2, by2)
        heatmap = 0.5 * (heatmap1 + heatmap2)

        heatmapimg1 =  heatmap + np.float32(bx1)
        heatmapimg1 = heatmapimg1 / np.max(heatmapimg1)
        heatmapimg2 =  heatmap + np.float32(bx2)
        heatmapimg2 = heatmapimg2 / np.max(heatmapimg2)
        return heatmap, heatmapimg1, heatmapimg2

    def proj_anjo(self):
        """
        *Function*: 
        :combinition of 'projection' and 'anti-join', similar to operator 'anti-join' but layer is controled by 'projection'

        *Inputs*:
        :2 inputs: x, x'
        :1 model: f

        *Returns*:
        :heatmap1
        :heatmapimg1
        :heatmap2
        :heatmapimg2
        """

        # case1: 1 input, 2 models
        if model_diff:
            bx = self.input_tup[0][0]
            self.model_kwargs1 = models_tup[0] 
            self.model1 = load_pretrained_model(**self.model_kwargs1)
            by1 = self.model1(bx)
            self.identity_interpreter1 = generate_identity(bx, by1, self.model_kwargs1, self.identity, self.identity_kwargs)


            self.model_kwargs2 = models_tup[1] 
            self.model2 = load_pretrained_model(**self.model_kwargs2)
            by2 = self.model2(bx)
            self.identity_interpreter2 = generate_identity(bx, by2, self.model_kwargs2, self.identity, self.identity_kwargs)

            heatmap1_1, heatmapimg1_1 = self.identity_interpreter1(bx, by1)  # interpreter1_cls1
            heatmap1_2, heatmapimg1_2 = self.identity_interpreter2(bx, by1)  # interpreter2_cls1
            heatmap2_1, heatmapimg2_1 = self.identity_interpreter1(bx, by2)  # interpreter1_cls2
            heatmap2_2, heatmapimg2_2 = self.identity_interpreter2(bx, by2)  # interpreter2_cls2

        # case2: 2 inputs, 1 model
        else:
            bx1, by1 = self.input_tup[0][0], self.input_tup[0][1] 
            bx2, by2 = self.input_tup[1][0], self.input_tup[1][1]

            self.identity_interpreter1 = generate_identity(bx, by1, self.model_kwargs, self.identity, self.identity_kwargs)
            self.identity_interpreter2 = generate_identity(bx, by2, self.model_kwargs, self.identity, self.identity_kwargs)
 
            heatmap1_1, heatmapimg1_1 = self.identity_interpreter1(bx1, by1)  # interpreter1_cls1_input1
            heatmap1_2, heatmapimg1_2 = self.identity_interpreter2(bx1, by2)  # interpreter2_cls2_input1
            heatmap2_1, heatmapimg2_1 = self.identity_interpreter1(bx2, by1)  # interpreter1_cls1_input2
            heatmap2_2, heatmapimg2_2 = self.identity_interpreter2(bx2, by2)  # interpreter2_cls2_input2

        heatmap1 = 0.5 * (heatmap1_1 + heatmap2_1)
        heatmapimg1 =  heatmap1 + np.float32(bx)
        heatmapimg1 = heatmapimg1 / np.max(heatmapimg1)

        heatmap2 = 0.5 * (heatmap1_2 + heatmap2_2)
        heatmapimg2 =  heatmap2 + np.float32(bx)
        heatmapimg2 = heatmapimg2 / np.max(heatmapimg2)

        return heatmap1, heatmapimg1, heatmap2, heatmapimg2 




    ###### THREE Pairs ######
    def slct_proj_join(self, region1, region2):
        """
        *Function*
        :combinition of 'selection', 'projection' and 'join', similar to compositer 'slct_join'

        *Inputs*:
        :2 input: x, x'
        :1 model: f

        *Returns*:
        :common heatmap: 
        :heatmapimg1:  
        :heatmapimg2: 
        """

        bx1, by1 = self.inputs_tup[0][0], self.inputs_tup[0][1] 
        bx2, by2 = self.inputs_tup[1][0], self.inputs_tup[1][1]

        pos1_0, pos1_1, pos1_2, pos1_3 = region1[0], region1[1], region1[2], region1[3]
        mat1 = np.zeros(bx1.shape)
        roi1 = bx1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)]
        mat1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)] = roi1
        mat1 = mat1.astype('float32')

        pos2_0, pos2_1, pos2_2, pos2_3 = region2[0], region2[1], region2[2], region2[3]
        mat2 = np.zeros(bx2.shape)
        roi2 = bx1[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)]
        mat2[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)] = roi2
        mat2 = mat2.astype('float32')

        ###### ??? todo, mat1 -> prediction != by1??)
        heatmap1, heatmapimg1 = self.identity_interpreter(mat1, by1)
        heatmap2, heatmapimg2 = self.identity_interpreter(mat2, by2)

        heatmap = 0.5 * (heatmap1 + heatmap2)
        
        heatmapimg1 =  heatmap + np.float32(mat1)
        heatmapimg1 = heatmapimg1 / np.max(heatmapimg1)

        heatmapimg2 =  heatmap + np.float32(mat2)
        heatmapimg2 = heatmapimg2 / np.max(heatmapimg2)

        return heatmap, heatmapimg1, heatmapimg2


    def slct_proj_anjo(self, region1, region2 = None, model_diff= False):
        """
        *Function*
        :combinition of 'selection', 'projection' and 'anti-join', similar to compositer 'slct_anjo'

        *Inputs*:
        case1:  2 input: x, x';   1 model: f
        case2:  1 input: x;       2 models: f, f'

        *Returns*:
        :heatmap1
        :heatmapimg1
        :heatmap2
        :heatmapimg2
        """

        if model_diff:
            bx, by = self.inputs_tup[0][0], self.inputs_tup[0][1] 
            pos1_0, pos1_1, pos1_2, pos1_3 = region1[0], region1[1], region1[2], region1[3]
            mat1 = np.zeros(bx.shape)
            roi1 = bx[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)]
            mat1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)] = roi1
            mat1 = mat1.astype('float32')

            self.model_kwargs1 = models_tup[0] 
            self.model1 = load_pretrained_model(**self.model_kwargs1)
            by1 = self.model1(bx)
            self.identity_interpreter1 = generate_identity(bx, by1, self.model_kwargs1, self.identity, self.identity_kwargs)

            self.model_kwargs2 = models_tup[1] 
            self.model2 = load_pretrained_model(**self.model_kwargs2)
            by2 = self.model2(bx)
            self.identity_interpreter2 = generate_identity(mat1, by2, self.model_kwargs2, self.identity, self.identity_kwargs)

            heatmap1_1, heatmapimg1_1 = self.identity_interpreter1(mat1, by1)  # interpreter1_cls1
            heatmap1_2, heatmapimg1_2 = self.identity_interpreter2(mat1, by1)  # interpreter2_cls1
            heatmap2_1, heatmapimg2_1 = self.identity_interpreter1(mat1, by2)  # interpreter1_cls2
            heatmap2_2, heatmapimg2_2 = self.identity_interpreter2(mat1, by2)  # interpreter2_cls2

        else:
            bx1, by1 = self.inputs_tup[0][0], self.inputs_tup[0][1] 
            bx2, by2 = self.inputs_tup[1][0], self.inputs_tup[1][1]

            pos1_0, pos1_1, pos1_2, pos1_3 = region1[0], region1[1], region1[2], region1[3]
            mat1 = np.zeros(bx1.shape)
            roi1 = bx1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)]
            mat1[:, int(pos1_0):int(pos1_1), int(pos1_2):int(pos1_3)] = roi1
            mat1 = mat1.astype('float32')

            pos2_0, pos2_1, pos2_2, pos2_3 = region2[0], region2[1], region2[2], region2[3]
            mat2 = np.zeros(bx2.shape)
            roi2 = bx2[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)]
            mat2[:, int(pos2_0):int(pos2_1), int(pos2_2):int(pos2_3)] = roi2
            mat2 = mat2.astype('float32')

            self.identity_interpreter1 = generate_identity(mat1, by1, self.model_kwargs, self.identity, self.identity_kwargs)
            self.identity_interpreter2 = generate_identity(mat2, by2, self.model_kwargs, self.identity, self.identity_kwargs)
 
            heatmap1_1, heatmapimg1_1 = self.identity_interpreter1(mat1, by1)  # interpreter1_cls1_input1
            heatmap1_2, heatmapimg1_2 = self.identity_interpreter2(mat1, by2)  # interpreter2_cls2_input1
            heatmap2_1, heatmapimg2_1 = self.identity_interpreter1(mat2, by1)  # interpreter1_cls1_input2
            heatmap2_2, heatmapimg2_2 = self.identity_interpreter2(mat2, by2)  # interpreter2_cls2_input2

        heatmap1 = 0.5 * (heatmap1_1 + heatmap2_1)
        heatmapimg1 =  heatmap1 + np.float32(bx)
        heatmapimg1 = heatmapimg1 / np.max(heatmapimg1)

        heatmap2 = 0.5 * (heatmap1_2 + heatmap2_2)
        heatmapimg2 =  heatmap2 + np.float32(bx)
        heatmapimg2 = heatmapimg2 / np.max(heatmapimg2)

        return heatmap1, heatmapimg1, heatmap2, heatmapimg2 



